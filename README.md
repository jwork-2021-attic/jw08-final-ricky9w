[![Open in Visual Studio Code](https://classroom.github.com/assets/open-in-vscode-f059dc9a6f8d3a56e377f745f24479a46679e63a5d9fe6f495e02850cd0d8118.svg)](https://classroom.github.com/online_ide?assignment_repo_id=6541018&assignment_repo_type=AssignmentRepo)

# jw08

![](/assets/screenshot.png)

## 游戏介绍

一个简单的吃豆人游戏, 支持最多 4 人网络对战.

### 灵感来源

功能机时代手机上总会附带一些以 `.jar` 结尾的游戏, 小时候并不知道这些后缀名的含义, 现在回想起来才发现原来这些手机上就跑着一个 Java 虚拟机, 这些游戏也是用 Java 开发并打包的. 因此想复刻一个吃豆人小游戏.

### 操作方法

使用 WASD 控制玩家上下移动.

躲开守卫的巡视并吃掉尽可能多的豆子!

### 游戏机制

玩家需要收集尽可能多的豆子, 每吃到一个豆子加 50 分. 两个玩家相遇时, 得分更高的玩家可以吃掉得分低的玩家.

出现如下情况时游戏结束:

1. 时间耗尽. 游戏中有一个计时器, 初步设定为100秒. 时间耗尽则游戏结束, 得分最高的玩家获胜.
2. 存活最久. 如果地图上只剩一个玩家, 则该玩家获胜.

**为了防止某些玩家"苟"在角落里通过 `规则2` 获胜(类比各种吃鸡游戏里的打法), 如果某个玩家一段时间内没有得分进账, 将会扣去 50 分作为"体能消耗", 借此鼓励左右玩家活跃起来.**

## 游戏开发

### 开发平台

`Debian 11, 5.10.16.3-microsoft-standard-WSL2` 

`openjdk 11.0.13 2021-10-19`

`OpenJDK Runtime Environment (build 11.0.13+8-post-Debian-1deb11u1)` 

`OpenJDK 64-Bit Server VM (build 11.0.13+8-post-Debian-1deb11u1, mixed mode, sharing)` 

### 开发过程

游戏基于 `FXGL 11.7` 引擎开发. 起初是由于在课上听老师提了一嘴 `FXGL` 项目, 觉得项目做出来的游戏比较精致, 而且引擎还是开源的, 于是就放弃了 jw05 和之前已有的项目.

开发过程中我感受到, 这次基于现有引擎的开发**对于学习来说有几个不利因素**:

+ 引擎已经将很多底层逻辑封装好, 直接调包学不到东西
+ 资料少, 文档不全, 不熟悉引擎 API
+ 自己造轮子时需要面对比较复杂的底层实现

针对问题1, 我的改善方案是自己先实现一个稍小的 demo, 搞懂基本原理, 然后再看引擎中某些机制是怎么实现的, 将引擎中的实现方法和自己的方案进行比较, 从中总结出改进自己或者引擎的实现方案的利弊.

问题2也是这次开发过程中困扰我最多的. 不过在 VS Code 中按住 Ctrl 点击类或者方法可以跳转到相应源码, 阅读源码可以让我对引擎提供的 API, 各个类的属性以及基本工作方式有一个大致的了解, 另外阅读源码也能让我学到很多实用技巧和开发理念. 引擎的开发者在 Gitter 上有一个[讨论区]([AlmasB/FXGL - Gitter](https://gitter.im/AlmasB/FXGL)), 里面也有他对很多问题的回复, 这些问答也能提供很多信息.

此外, 开发者自己写了一些游戏 demo, 并且还做了一些视频讲解, 通过这些 demo 也能学到不少东西.

问题3主要出现在网络开发模块. 引擎本身的网络模块还处在 beta 阶段, 很多功能也不是太全面, 需要自己实现一些东西, 需要花不少时间了解一些底层实现.

### 框架设计

考虑到功能模块之间的独立性, 将游戏分为几个部分:

1. 游戏主要逻辑, 在项目根目录下
2. 文件 I/O, 数据存储与管理, 不同模块可能都需要用到这些功能, 因此封装后放在 `utils` 包中
3. 网络通信, 封装后放在 `network` 包中
4. UI 显示, 封装后放在 `ui` 包中
5. 配置文件, 分为两类, 一种是游戏中需要经常调用的一些常量, 定义在 `Config.java` 中, 方便统一查看和管理, 程序中直接引用也比较方便; 另一种是一些调用频率不高的资源文件, 例如 UI 中各个组件的布局, 地图文件等, 其中结构化的内容以 `xml` 等结构化数据进行存储, 地图等比较简单的数据以纯文本格式存储, 需要用到时通过文件 I/O 进行读取, 同样可以统一管理.

项目文件结构如下:

```
.
├── App.java
├── components
│   ├── ai
│   │   └── DelayChaseComponent.java
│   ├── Direction.java
│   ├── PlayerComponent.java
│   └── ScoreComponent.java
├── Config.java
├── network
│   ├── ActionData.java
│   ├── ActionType.java
│   └── NetMessage.java
├── PacFactory.java
├── PacType.java
├── ui
│   └── PacUIController.java
└── utils
    ├── PosData.java
    └── Position2D.java
```

### 游戏同步

多人网络对战游戏需要考虑同步问题, 帧同步和状态同步是最常用的两种模式. 其中帧同步模式下, 服务器仅仅负责转发/广播各个客户端的操作, 本身不进行状态处理, 大部分处理任务在客户端中进行; 状态同步模式下, 所有操作都会发送到服务器, 服务器中进行相应计算和处理, 将处理完成后的数据发送给各个客户端, 客户端仅仅负责显示.

本次作业由于同步数据量较小, 负担较轻, 因此采用状态同步方式. FXGL 引擎中原有的网络模块仅能支持 2 个玩家对战, 且多端同步性能不好, 因此这次大作业自己实现了网络环境下的多玩家状态同步.

### 单元测试

对项目进行测试, 覆盖率结果如下:

![](/assets/coverage.png)

## 效果展示

| 游戏机制                                                     | 保存和加载                                                   | 网络对战*                                                    |
| ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| [在线观看](https://aarons-videos.oss-cn-beijing.aliyuncs.com/191220119%E7%8E%8B%E6%AF%93%E7%90%A6_%E6%B8%B8%E6%88%8F%E6%9C%BA%E5%88%B6.mp4) | [在线观看](https://aarons-videos.oss-cn-beijing.aliyuncs.com/191220119%E7%8E%8B%E6%AF%93%E7%90%A6_%E4%BF%9D%E5%AD%98%E5%92%8C%E5%8A%A0%E8%BD%BD.mp4) | [在线观看](https://aarons-videos.oss-cn-beijing.aliyuncs.com/191220119%E7%8E%8B%E6%AF%93%E7%90%A6_%E7%BD%91%E7%BB%9C%E5%AF%B9%E6%88%98.mp4) |
| [视频文件](/assets/191220119王毓琦_游戏机制.mp4)             | [视频文件](/assets/191220119王毓琦_保存和加载.mp4)           | [视频文件](/assets/191220119王毓琦_网络对战.mp4)             |

*网络对战部分录制视频时降低了怪物速度

关于游戏设计部分更加详细的报告请参考[实验报告](./report.pdf).